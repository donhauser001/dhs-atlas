# dhs-atlas 租户开通蓝图（Provisioning Blueprint）

> **版本**: v1.0  
> **创建日期**: 2025-12-28  
> **文档性质**: 工程执行文档  
> **相关文档**: [租户隔离三阶段路线图](./租户隔离三阶段路线图.md) · [租户开通工作流](./租户开通工作流.md)

---

## 一、概述

本文档定义 Phase 2/3 的 Provisioning 状态机的**工程实现细节**，包括：

- 状态定义与转移规则
- 事件日志要求
- 失败处理与回滚策略
- 审计要求
- 代码结构建议

---

## 二、Provisioning 服务架构

### 2.1 服务边界

```
┌─────────────────────────────────────────────────────────────────────┐
│                    Provisioning 服务架构                             │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│   ┌─────────────────────────────────────────────────────────────┐   │
│   │                  Provisioning Service                        │   │
│   │                                                             │   │
│   │   ┌───────────────┐ ┌───────────────┐ ┌───────────────┐    │   │
│   │   │  Coordinator  │ │    Workers    │ │   Scheduler   │    │   │
│   │   │  (状态机驱动)  │ │   (任务执行)   │ │   (定时任务)   │    │   │
│   │   └───────┬───────┘ └───────┬───────┘ └───────┬───────┘    │   │
│   │           │                 │                 │             │   │
│   │           └─────────────────┼─────────────────┘             │   │
│   │                             │                               │   │
│   │                             ▼                               │   │
│   │   ┌─────────────────────────────────────────────────────┐  │   │
│   │   │                   Event Bus                          │  │   │
│   │   └─────────────────────────────────────────────────────┘  │   │
│   │                             │                               │   │
│   └─────────────────────────────┼───────────────────────────────┘   │
│                                 │                                   │
│         ┌───────────────────────┼───────────────────────┐          │
│         │                       │                       │          │
│         ▼                       ▼                       ▼          │
│   ┌───────────┐           ┌───────────┐           ┌───────────┐   │
│   │  Database │           │  Storage  │           │  Instance │   │
│   │  Provider │           │  Provider │           │  Provider │   │
│   └───────────┘           └───────────┘           └───────────┘   │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 2.2 核心组件

| 组件 | 职责 |
|------|------|
| **Coordinator** | 状态机驱动，协调整个 Provisioning 流程 |
| **Workers** | 执行具体任务（创建 DB、迁移数据等） |
| **Scheduler** | 定时检查超时、重试、清理 |
| **Event Bus** | 事件发布/订阅，解耦各组件 |
| **Providers** | 资源提供者抽象（DB/Storage/Instance） |

---

## 三、Phase 2：DB Provisioning 状态机

### 3.1 状态定义

```typescript
enum DbProvisioningState {
  // 初始状态
  REQUESTED = 'requested',
  
  // 执行中状态
  ALLOCATING_DB = 'allocating_db',
  RUNNING_MIGRATIONS = 'running_migrations',
  MIGRATING_DATA = 'migrating_data',
  VERIFYING = 'verifying',
  SWITCHING = 'switching',
  
  // 终态
  READY = 'ready',
  FAILED = 'failed',
  ROLLED_BACK = 'rolled_back',
  CANCELLED = 'cancelled'
}
```

### 3.2 状态转移图

```
┌─────────────────────────────────────────────────────────────────────┐
│                    DB Provisioning 状态转移                          │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│   REQUESTED ────────────────► ALLOCATING_DB                        │
│                                     │                               │
│                                     │ DB 创建成功                   │
│                                     ▼                               │
│                             RUNNING_MIGRATIONS                      │
│                                     │                               │
│                                     │ Migrations 完成               │
│                                     ▼                               │
│                              MIGRATING_DATA                         │
│                                     │                               │
│                                     │ 数据迁移完成                   │
│                                     ▼                               │
│                                VERIFYING                            │
│                                     │                               │
│                       ┌─────────────┼─────────────┐                │
│                       │ 验证通过     │             │ 验证失败       │
│                       ▼             │             ▼                │
│                   SWITCHING         │          FAILED              │
│                       │             │             │                │
│                       │ 切换完成    │             │ 可重试/回滚    │
│                       ▼             │             ▼                │
│                     READY           │        ROLLED_BACK           │
│                                     │                               │
│   任意状态 ────────► FAILED ───────┴──────────► ROLLED_BACK       │
│                  (超时/异常)                    (回滚完成)          │
│                                                                     │
│   任意状态 ────────► CANCELLED (用户取消)                          │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 3.3 状态处理器

```typescript
interface StateHandler {
  state: DbProvisioningState;
  
  // 进入状态时执行
  onEnter(session: DbProvisioningSession): Promise<void>;
  
  // 执行状态任务
  execute(session: DbProvisioningSession): Promise<StateTransitionResult>;
  
  // 超时时间
  timeout: number;
  
  // 失败时是否可重试
  retryable: boolean;
  
  // 最大重试次数
  maxRetries: number;
}

// 状态转移结果
interface StateTransitionResult {
  success: boolean;
  nextState?: DbProvisioningState;
  error?: ProvisioningError;
  data?: Record<string, unknown>;
}
```

### 3.4 各状态实现

#### 3.4.1 ALLOCATING_DB

```typescript
const allocatingDbHandler: StateHandler = {
  state: DbProvisioningState.ALLOCATING_DB,
  timeout: 10 * 60 * 1000, // 10 分钟
  retryable: true,
  maxRetries: 3,
  
  async onEnter(session) {
    await emitEvent('provisioning.db.allocating', {
      sessionId: session.id,
      enterpriseId: session.enterpriseId,
    });
  },
  
  async execute(session): Promise<StateTransitionResult> {
    try {
      // 1. 生成数据库名称
      const dbName = `tenant_${session.enterpriseId.replace(/-/g, '_')}`;
      
      // 2. 创建数据库
      const database = await databaseProvider.create({
        name: dbName,
        region: session.request.region || 'default',
        spec: session.request.dbSpec || 'small',
      });
      
      // 3. 更新 session
      session.allocatedDb = {
        databaseId: database.id,
        host: database.host,
        name: database.name,
        credentials: await encryptCredentials(database.credentials),
      };
      
      // 4. 返回成功
      return {
        success: true,
        nextState: DbProvisioningState.RUNNING_MIGRATIONS,
        data: { databaseId: database.id },
      };
    } catch (error) {
      return {
        success: false,
        error: {
          code: 'DB_ALLOCATION_FAILED',
          message: error.message,
          retryable: isRetryableError(error),
        },
      };
    }
  },
};
```

#### 3.4.2 RUNNING_MIGRATIONS

```typescript
const runningMigrationsHandler: StateHandler = {
  state: DbProvisioningState.RUNNING_MIGRATIONS,
  timeout: 30 * 60 * 1000, // 30 分钟
  retryable: true,
  maxRetries: 2,
  
  async onEnter(session) {
    await emitEvent('provisioning.migrations.started', {
      sessionId: session.id,
      databaseId: session.allocatedDb.databaseId,
    });
  },
  
  async execute(session): Promise<StateTransitionResult> {
    try {
      const connection = await createConnection({
        host: session.allocatedDb.host,
        database: session.allocatedDb.name,
        credentials: await decryptCredentials(session.allocatedDb.credentials),
      });
      
      // 运行所有 migrations
      const migrationResult = await runMigrations(connection, {
        onProgress: async (migration) => {
          await emitEvent('provisioning.migration.applied', {
            sessionId: session.id,
            migration: migration.name,
          });
        },
      });
      
      if (!migrationResult.success) {
        return {
          success: false,
          error: {
            code: 'MIGRATIONS_FAILED',
            message: migrationResult.error,
            retryable: false,
          },
        };
      }
      
      return {
        success: true,
        nextState: DbProvisioningState.MIGRATING_DATA,
        data: { migrationsApplied: migrationResult.applied },
      };
    } catch (error) {
      return {
        success: false,
        error: {
          code: 'MIGRATIONS_FAILED',
          message: error.message,
          retryable: true,
        },
      };
    }
  },
};
```

#### 3.4.3 MIGRATING_DATA

```typescript
const migratingDataHandler: StateHandler = {
  state: DbProvisioningState.MIGRATING_DATA,
  timeout: 2 * 60 * 60 * 1000, // 2 小时（大数据量）
  retryable: true,
  maxRetries: 1,
  
  async onEnter(session) {
    await emitEvent('provisioning.data_migration.started', {
      sessionId: session.id,
      enterpriseId: session.enterpriseId,
    });
  },
  
  async execute(session): Promise<StateTransitionResult> {
    try {
      const sourceConnection = await getSharedConnection();
      const targetConnection = await createConnection({
        host: session.allocatedDb.host,
        database: session.allocatedDb.name,
        credentials: await decryptCredentials(session.allocatedDb.credentials),
      });
      
      const tables = await getTableList();
      let totalRows = 0;
      let migratedRows = 0;
      
      for (const table of tables) {
        // 统计行数
        const count = await sourceConnection.count(
          table,
          { enterprise_id: session.enterpriseId }
        );
        totalRows += count;
        
        // 分批迁移
        const batchSize = 1000;
        let offset = 0;
        
        while (offset < count) {
          const rows = await sourceConnection.query(
            `SELECT * FROM ${table} WHERE enterprise_id = $1 LIMIT $2 OFFSET $3`,
            [session.enterpriseId, batchSize, offset]
          );
          
          if (rows.length > 0) {
            await targetConnection.batchInsert(table, rows);
            migratedRows += rows.length;
            
            // 发送进度事件
            await emitEvent('provisioning.data_migration.progress', {
              sessionId: session.id,
              table,
              progress: { totalRows, migratedRows },
            });
          }
          
          offset += batchSize;
        }
      }
      
      return {
        success: true,
        nextState: DbProvisioningState.VERIFYING,
        data: { totalRows, migratedRows },
      };
    } catch (error) {
      return {
        success: false,
        error: {
          code: 'DATA_MIGRATION_FAILED',
          message: error.message,
          retryable: true,
        },
      };
    }
  },
};
```

#### 3.4.4 VERIFYING

```typescript
const verifyingHandler: StateHandler = {
  state: DbProvisioningState.VERIFYING,
  timeout: 30 * 60 * 1000, // 30 分钟
  retryable: true,
  maxRetries: 2,
  
  async onEnter(session) {
    await emitEvent('provisioning.verification.started', {
      sessionId: session.id,
    });
  },
  
  async execute(session): Promise<StateTransitionResult> {
    try {
      const sourceConnection = await getSharedConnection();
      const targetConnection = await createConnection({
        host: session.allocatedDb.host,
        database: session.allocatedDb.name,
        credentials: await decryptCredentials(session.allocatedDb.credentials),
      });
      
      const tables = await getTableList();
      const discrepancies: Discrepancy[] = [];
      
      for (const table of tables) {
        // 验证行数
        const sourceCount = await sourceConnection.count(
          table,
          { enterprise_id: session.enterpriseId }
        );
        const targetCount = await targetConnection.count(table);
        
        if (sourceCount !== targetCount) {
          discrepancies.push({
            table,
            type: 'row_count_mismatch',
            sourceCount,
            targetCount,
          });
        }
        
        // 验证校验和（可选，对大表可跳过）
        if (sourceCount < 10000) {
          const sourceChecksum = await computeChecksum(
            sourceConnection, table, session.enterpriseId
          );
          const targetChecksum = await computeChecksum(
            targetConnection, table
          );
          
          if (sourceChecksum !== targetChecksum) {
            discrepancies.push({
              table,
              type: 'checksum_mismatch',
              sourceChecksum,
              targetChecksum,
            });
          }
        }
      }
      
      if (discrepancies.length > 0) {
        return {
          success: false,
          error: {
            code: 'VERIFICATION_FAILED',
            message: `Found ${discrepancies.length} discrepancies`,
            details: discrepancies,
            retryable: true, // 可能是数据变更导致，重试
          },
        };
      }
      
      return {
        success: true,
        nextState: DbProvisioningState.SWITCHING,
      };
    } catch (error) {
      return {
        success: false,
        error: {
          code: 'VERIFICATION_FAILED',
          message: error.message,
          retryable: true,
        },
      };
    }
  },
};
```

#### 3.4.5 SWITCHING

```typescript
const switchingHandler: StateHandler = {
  state: DbProvisioningState.SWITCHING,
  timeout: 5 * 60 * 1000, // 5 分钟
  retryable: false, // 切换不可重试，需要手动介入
  maxRetries: 0,
  
  async onEnter(session) {
    await emitEvent('provisioning.switching.started', {
      sessionId: session.id,
    });
  },
  
  async execute(session): Promise<StateTransitionResult> {
    try {
      // 1. 更新 tenant_runtime
      await db.tenantRuntime.update({
        where: { enterpriseId: session.enterpriseId },
        data: {
          isolationMode: 'dedicated_db',
          databaseId: session.allocatedDb.databaseId,
          databaseHost: session.allocatedDb.host,
          databaseName: session.allocatedDb.name,
          status: 'active',
          updatedAt: new Date(),
        },
      });
      
      // 2. 刷新 TenantDbResolver 缓存
      await tenantDbResolver.invalidateCache(session.enterpriseId);
      
      // 3. 验证新连接工作正常
      const connection = await tenantDbResolver.getConnection(session.enterpriseId);
      await connection.query('SELECT 1');
      
      // 4. （可选）标记源数据为已迁移
      await markSourceDataAsMigrated(session.enterpriseId);
      
      return {
        success: true,
        nextState: DbProvisioningState.READY,
      };
    } catch (error) {
      return {
        success: false,
        error: {
          code: 'SWITCHING_FAILED',
          message: error.message,
          retryable: false, // 切换失败需要手动介入
        },
      };
    }
  },
};
```

### 3.5 回滚策略

```typescript
interface RollbackStrategy {
  fromState: DbProvisioningState;
  actions: RollbackAction[];
}

interface RollbackAction {
  name: string;
  execute: (session: DbProvisioningSession) => Promise<void>;
  continueOnError: boolean;
}

const rollbackStrategies: RollbackStrategy[] = [
  {
    fromState: DbProvisioningState.ALLOCATING_DB,
    actions: [
      {
        name: 'delete_database',
        execute: async (session) => {
          if (session.allocatedDb?.databaseId) {
            await databaseProvider.delete(session.allocatedDb.databaseId);
          }
        },
        continueOnError: true,
      },
    ],
  },
  {
    fromState: DbProvisioningState.RUNNING_MIGRATIONS,
    actions: [
      {
        name: 'delete_database',
        execute: async (session) => {
          if (session.allocatedDb?.databaseId) {
            await databaseProvider.delete(session.allocatedDb.databaseId);
          }
        },
        continueOnError: true,
      },
    ],
  },
  {
    fromState: DbProvisioningState.MIGRATING_DATA,
    actions: [
      {
        name: 'delete_database',
        execute: async (session) => {
          if (session.allocatedDb?.databaseId) {
            await databaseProvider.delete(session.allocatedDb.databaseId);
          }
        },
        continueOnError: true,
      },
    ],
  },
  {
    fromState: DbProvisioningState.VERIFYING,
    actions: [
      {
        name: 'delete_database',
        execute: async (session) => {
          if (session.allocatedDb?.databaseId) {
            await databaseProvider.delete(session.allocatedDb.databaseId);
          }
        },
        continueOnError: true,
      },
    ],
  },
  {
    fromState: DbProvisioningState.SWITCHING,
    actions: [
      // 切换失败时，需要恢复 tenant_runtime
      {
        name: 'restore_tenant_runtime',
        execute: async (session) => {
          await db.tenantRuntime.update({
            where: { enterpriseId: session.enterpriseId },
            data: {
              isolationMode: 'shared',
              databaseId: null,
              databaseHost: null,
              databaseName: null,
              status: 'active',
              updatedAt: new Date(),
            },
          });
        },
        continueOnError: false, // 这步失败需要停止
      },
      {
        name: 'invalidate_cache',
        execute: async (session) => {
          await tenantDbResolver.invalidateCache(session.enterpriseId);
        },
        continueOnError: true,
      },
      {
        name: 'delete_database',
        execute: async (session) => {
          if (session.allocatedDb?.databaseId) {
            await databaseProvider.delete(session.allocatedDb.databaseId);
          }
        },
        continueOnError: true,
      },
    ],
  },
];
```

### 3.6 事件日志要求

| 事件类型 | 触发时机 | 必须字段 |
|---------|---------|---------|
| `provisioning.db.requested` | 请求提交 | sessionId, enterpriseId, request |
| `provisioning.db.allocating` | 开始分配 DB | sessionId, enterpriseId |
| `provisioning.db.allocated` | DB 分配完成 | sessionId, databaseId |
| `provisioning.migrations.started` | 开始迁移 | sessionId, databaseId |
| `provisioning.migration.applied` | 单个 migration 完成 | sessionId, migration |
| `provisioning.migrations.completed` | 迁移全部完成 | sessionId, count |
| `provisioning.data_migration.started` | 开始数据迁移 | sessionId, enterpriseId |
| `provisioning.data_migration.progress` | 数据迁移进度 | sessionId, table, progress |
| `provisioning.data_migration.completed` | 数据迁移完成 | sessionId, totalRows |
| `provisioning.verification.started` | 开始验证 | sessionId |
| `provisioning.verification.completed` | 验证完成 | sessionId, result |
| `provisioning.switching.started` | 开始切换 | sessionId |
| `provisioning.switching.completed` | 切换完成 | sessionId |
| `provisioning.db.ready` | 就绪 | sessionId, enterpriseId, databaseId |
| `provisioning.db.failed` | 失败 | sessionId, error |
| `provisioning.db.rollback.started` | 开始回滚 | sessionId |
| `provisioning.db.rollback.completed` | 回滚完成 | sessionId |

---

## 四、Phase 3：Instance Provisioning 状态机

### 4.1 状态定义

```typescript
enum InstanceProvisioningState {
  // 初始状态
  REQUESTED = 'requested',
  
  // 执行中状态
  ALLOCATING_INSTANCE = 'allocating_instance',
  ALLOCATING_DB = 'allocating_db',
  ALLOCATING_STORAGE = 'allocating_storage',
  DEPLOYING_APP = 'deploying_app',
  RUNNING_MIGRATIONS = 'running_migrations',
  MIGRATING_DATA = 'migrating_data',
  CONFIGURING_DOMAIN = 'configuring_domain',
  ISSUING_CERT = 'issuing_cert',
  VERIFYING = 'verifying',
  
  // 终态
  READY = 'ready',
  FAILED = 'failed',
  ROLLED_BACK = 'rolled_back',
  CANCELLED = 'cancelled'
}
```

### 4.2 状态转移图

```
┌─────────────────────────────────────────────────────────────────────┐
│                Instance Provisioning 状态转移                        │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│   REQUESTED                                                         │
│       │                                                             │
│       ▼                                                             │
│   ALLOCATING_INSTANCE ───► ALLOCATING_DB ───► ALLOCATING_STORAGE   │
│                                                     │               │
│                                                     ▼               │
│                                              DEPLOYING_APP          │
│                                                     │               │
│                                                     ▼               │
│                                            RUNNING_MIGRATIONS       │
│                                                     │               │
│                                                     ▼               │
│                                              MIGRATING_DATA         │
│                                                     │               │
│                                                     ▼               │
│                                           CONFIGURING_DOMAIN        │
│                                                     │               │
│                                                     ▼               │
│                                              ISSUING_CERT           │
│                                                     │               │
│                                                     ▼               │
│                                                VERIFYING            │
│                                                     │               │
│                                       ┌─────────────┴─────────────┐ │
│                                       │                           │ │
│                                       ▼                           ▼ │
│                                     READY                      FAILED│
│                                                                   │ │
│                                                                   ▼ │
│                                                            ROLLED_BACK│
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 4.3 关键状态实现

#### 4.3.1 ALLOCATING_INSTANCE

```typescript
const allocatingInstanceHandler: StateHandler = {
  state: InstanceProvisioningState.ALLOCATING_INSTANCE,
  timeout: 15 * 60 * 1000, // 15 分钟
  retryable: true,
  maxRetries: 3,
  
  async execute(session): Promise<StateTransitionResult> {
    try {
      // 生成实例名称
      const slug = session.request.preferredSlug || 
        generateSlug(session.enterpriseId);
      
      // 验证 slug 可用
      const existing = await db.tenantRuntime.findFirst({
        where: { primaryDomain: { contains: slug } },
      });
      if (existing) {
        return {
          success: false,
          error: {
            code: 'SLUG_ALREADY_EXISTS',
            message: `Slug ${slug} is already in use`,
            retryable: false,
          },
        };
      }
      
      // 创建实例
      const instance = await instanceProvider.create({
        name: `tenant-${slug}`,
        region: session.request.region,
        spec: mapSpec(session.request.instanceSpec),
        labels: {
          tenantId: session.enterpriseId,
          environment: 'production',
        },
      });
      
      // 更新 session
      session.allocatedResources = {
        ...session.allocatedResources,
        instanceId: instance.id,
        instanceHost: instance.host,
        slug,
      };
      
      return {
        success: true,
        nextState: InstanceProvisioningState.ALLOCATING_DB,
        data: { instanceId: instance.id },
      };
    } catch (error) {
      return {
        success: false,
        error: {
          code: 'INSTANCE_ALLOCATION_FAILED',
          message: error.message,
          retryable: isRetryableError(error),
        },
      };
    }
  },
};
```

#### 4.3.2 DEPLOYING_APP

```typescript
const deployingAppHandler: StateHandler = {
  state: InstanceProvisioningState.DEPLOYING_APP,
  timeout: 30 * 60 * 1000, // 30 分钟
  retryable: true,
  maxRetries: 2,
  
  async execute(session): Promise<StateTransitionResult> {
    try {
      const { instanceId, slug } = session.allocatedResources;
      
      // 获取当前稳定版本
      const version = await releaseService.getStableVersion();
      
      // 准备配置
      const config = {
        TENANT_ID: session.enterpriseId,
        INSTANCE_ID: instanceId,
        DATABASE_HOST: session.allocatedResources.databaseHost,
        DATABASE_NAME: session.allocatedResources.databaseName,
        STORAGE_BUCKET: session.allocatedResources.storageBucket,
        PRIMARY_DOMAIN: `${slug}.${PLATFORM_DOMAIN}`,
        AI_GATEWAY_URL: AI_GATEWAY_URL,
        ENTITLEMENT_SERVICE_URL: ENTITLEMENT_SERVICE_URL,
      };
      
      // 部署应用
      const deployment = await deploymentService.deploy(instanceId, {
        image: `${IMAGE_REGISTRY}/dhs-atlas:${version}`,
        config,
        replicas: getReplicaCount(session.request.instanceSpec),
      });
      
      // 等待部署完成
      await waitForDeployment(deployment.id, {
        timeout: 20 * 60 * 1000, // 20 分钟
        onProgress: async (status) => {
          await emitEvent('provisioning.deployment.progress', {
            sessionId: session.id,
            status,
          });
        },
      });
      
      // 健康检查
      const healthy = await healthCheck(instanceId);
      if (!healthy) {
        return {
          success: false,
          error: {
            code: 'DEPLOYMENT_UNHEALTHY',
            message: 'Instance failed health check after deployment',
            retryable: true,
          },
        };
      }
      
      return {
        success: true,
        nextState: InstanceProvisioningState.RUNNING_MIGRATIONS,
        data: { version, deploymentId: deployment.id },
      };
    } catch (error) {
      return {
        success: false,
        error: {
          code: 'DEPLOYMENT_FAILED',
          message: error.message,
          retryable: true,
        },
      };
    }
  },
};
```

#### 4.3.3 CONFIGURING_DOMAIN

```typescript
const configuringDomainHandler: StateHandler = {
  state: InstanceProvisioningState.CONFIGURING_DOMAIN,
  timeout: 10 * 60 * 1000, // 10 分钟
  retryable: true,
  maxRetries: 3,
  
  async execute(session): Promise<StateTransitionResult> {
    try {
      const { slug, instanceHost } = session.allocatedResources;
      
      // 1. 配置二级域名路由
      const primaryDomain = `${slug}.${PLATFORM_DOMAIN}`;
      
      await routingService.addRoute({
        domain: primaryDomain,
        target: instanceHost,
        healthCheck: {
          path: '/health',
          interval: 30,
        },
      });
      
      // 2. 如果有自定义域名，初始化验证流程
      if (session.request.customDomain) {
        const binding = await domainService.initiateBind({
          tenantId: session.enterpriseId,
          domain: session.request.customDomain,
          target: primaryDomain,
        });
        
        session.allocatedResources.customDomainBindingId = binding.id;
      }
      
      // 3. 更新 session
      session.allocatedResources.primaryDomain = primaryDomain;
      
      return {
        success: true,
        nextState: InstanceProvisioningState.ISSUING_CERT,
        data: { primaryDomain },
      };
    } catch (error) {
      return {
        success: false,
        error: {
          code: 'DOMAIN_CONFIGURATION_FAILED',
          message: error.message,
          retryable: true,
        },
      };
    }
  },
};
```

### 4.4 回滚策略

```typescript
const instanceRollbackStrategies: RollbackStrategy[] = [
  {
    fromState: InstanceProvisioningState.ALLOCATING_INSTANCE,
    actions: [
      {
        name: 'delete_instance',
        execute: async (session) => {
          if (session.allocatedResources?.instanceId) {
            await instanceProvider.delete(session.allocatedResources.instanceId);
          }
        },
        continueOnError: true,
      },
    ],
  },
  {
    fromState: InstanceProvisioningState.DEPLOYING_APP,
    actions: [
      {
        name: 'delete_database',
        execute: async (session) => {
          if (session.allocatedResources?.databaseId) {
            await databaseProvider.delete(session.allocatedResources.databaseId);
          }
        },
        continueOnError: true,
      },
      {
        name: 'delete_storage',
        execute: async (session) => {
          if (session.allocatedResources?.storageId) {
            await storageProvider.delete(session.allocatedResources.storageId);
          }
        },
        continueOnError: true,
      },
      {
        name: 'delete_instance',
        execute: async (session) => {
          if (session.allocatedResources?.instanceId) {
            await instanceProvider.delete(session.allocatedResources.instanceId);
          }
        },
        continueOnError: true,
      },
    ],
  },
  {
    fromState: InstanceProvisioningState.CONFIGURING_DOMAIN,
    actions: [
      {
        name: 'remove_route',
        execute: async (session) => {
          if (session.allocatedResources?.primaryDomain) {
            await routingService.removeRoute(session.allocatedResources.primaryDomain);
          }
        },
        continueOnError: true,
      },
      {
        name: 'cancel_domain_binding',
        execute: async (session) => {
          if (session.allocatedResources?.customDomainBindingId) {
            await domainService.cancelBind(session.allocatedResources.customDomainBindingId);
          }
        },
        continueOnError: true,
      },
      // ... 其他资源清理
    ],
  },
];
```

---

## 五、Coordinator 实现

### 5.1 状态机驱动器

```typescript
class ProvisioningCoordinator {
  private handlers: Map<string, StateHandler>;
  private rollbackStrategies: Map<string, RollbackStrategy>;
  
  constructor(
    handlers: StateHandler[],
    rollbackStrategies: RollbackStrategy[]
  ) {
    this.handlers = new Map(handlers.map(h => [h.state, h]));
    this.rollbackStrategies = new Map(rollbackStrategies.map(s => [s.fromState, s]));
  }
  
  async run(session: ProvisioningSession): Promise<void> {
    while (!this.isTerminalState(session.state)) {
      const handler = this.handlers.get(session.state);
      if (!handler) {
        throw new Error(`No handler for state: ${session.state}`);
      }
      
      try {
        // 进入状态
        await handler.onEnter(session);
        
        // 执行状态任务（带超时）
        const result = await withTimeout(
          handler.execute(session),
          handler.timeout
        );
        
        if (result.success) {
          // 状态转移
          await this.transition(session, result.nextState!, result.data);
        } else {
          // 处理失败
          await this.handleFailure(session, handler, result.error!);
        }
      } catch (error) {
        // 超时或异常
        await this.handleError(session, handler, error);
      }
    }
  }
  
  private async transition(
    session: ProvisioningSession,
    nextState: string,
    data?: Record<string, unknown>
  ): Promise<void> {
    const previousState = session.state;
    session.state = nextState;
    session.stateHistory.push({
      from: previousState,
      to: nextState,
      timestamp: new Date(),
      data,
    });
    
    await this.saveSession(session);
    
    await emitEvent('provisioning.state.transitioned', {
      sessionId: session.id,
      from: previousState,
      to: nextState,
    });
  }
  
  private async handleFailure(
    session: ProvisioningSession,
    handler: StateHandler,
    error: ProvisioningError
  ): Promise<void> {
    session.error = error;
    session.retryCount = (session.retryCount || 0) + 1;
    
    if (error.retryable && session.retryCount < handler.maxRetries) {
      // 等待后重试
      await delay(this.calculateBackoff(session.retryCount));
      return; // 继续循环，重试当前状态
    }
    
    // 进入失败状态
    await this.transition(session, 'failed');
  }
  
  private async rollback(session: ProvisioningSession): Promise<void> {
    const strategy = this.rollbackStrategies.get(session.state);
    if (!strategy) {
      // 无需回滚或无策略
      await this.transition(session, 'rolled_back');
      return;
    }
    
    await emitEvent('provisioning.rollback.started', {
      sessionId: session.id,
      fromState: session.state,
    });
    
    for (const action of strategy.actions) {
      try {
        await action.execute(session);
      } catch (error) {
        await emitEvent('provisioning.rollback.action_failed', {
          sessionId: session.id,
          action: action.name,
          error: error.message,
        });
        
        if (!action.continueOnError) {
          throw error; // 停止回滚，需要人工介入
        }
      }
    }
    
    await this.transition(session, 'rolled_back');
    
    await emitEvent('provisioning.rollback.completed', {
      sessionId: session.id,
    });
  }
  
  private isTerminalState(state: string): boolean {
    return ['ready', 'failed', 'rolled_back', 'cancelled'].includes(state);
  }
}
```

### 5.2 定时任务

```typescript
class ProvisioningScheduler {
  // 检查超时的 session
  @Cron('*/5 * * * *') // 每 5 分钟
  async checkTimeouts(): Promise<void> {
    const timeoutSessions = await db.provisioningSession.findMany({
      where: {
        state: { notIn: ['ready', 'failed', 'rolled_back', 'cancelled'] },
        updatedAt: { lt: new Date(Date.now() - 30 * 60 * 1000) }, // 30 分钟无更新
      },
    });
    
    for (const session of timeoutSessions) {
      await emitEvent('provisioning.session.timeout', {
        sessionId: session.id,
        state: session.state,
      });
      
      // 标记为失败
      await updateSession(session.id, {
        state: 'failed',
        error: {
          code: 'TIMEOUT',
          message: `Session timed out in state: ${session.state}`,
          retryable: true,
        },
      });
    }
  }
  
  // 清理已完成的 session（保留一定时间供审计）
  @Cron('0 2 * * *') // 每天凌晨 2 点
  async cleanupOldSessions(): Promise<void> {
    const cutoff = new Date(Date.now() - 90 * 24 * 60 * 60 * 1000); // 90 天前
    
    await db.provisioningSession.deleteMany({
      where: {
        state: { in: ['ready', 'rolled_back', 'cancelled'] },
        completedAt: { lt: cutoff },
      },
    });
  }
}
```

---

## 六、审计要求

### 6.1 必须记录的审计信息

| 信息类型 | 字段 | 说明 |
|---------|------|------|
| **操作者** | actor.type, actor.id | 谁触发的 Provisioning |
| **目标** | enterpriseId, tenantId | 为哪个租户操作 |
| **资源** | resourceType, resourceId | 创建/删除了什么资源 |
| **状态** | fromState, toState | 状态变化 |
| **结果** | success, error | 是否成功，错误信息 |
| **时间** | timestamp, duration | 何时发生，耗时多久 |

### 6.2 审计事件结构

```typescript
interface ProvisioningAuditEvent {
  // 事件标识
  eventId: string;
  eventType: string;
  
  // 操作者
  actor: {
    type: 'user' | 'system' | 'scheduler';
    id: string;
    name?: string;
  };
  
  // 目标
  target: {
    enterpriseId: string;
    sessionId: string;
  };
  
  // 资源（如有）
  resource?: {
    type: 'database' | 'instance' | 'storage' | 'domain';
    id: string;
    action: 'created' | 'deleted' | 'updated';
  };
  
  // 状态（如有）
  stateChange?: {
    from: string;
    to: string;
  };
  
  // 结果
  result: {
    success: boolean;
    error?: {
      code: string;
      message: string;
    };
  };
  
  // 时间
  timestamp: Date;
  duration?: number;
  
  // 元数据
  metadata?: Record<string, unknown>;
}
```

### 6.3 审计日志保留策略

| 日志类型 | 保留时间 | 说明 |
|---------|---------|------|
| **状态变更** | 3 年 | 合规要求 |
| **资源操作** | 3 年 | 资源生命周期 |
| **错误/失败** | 1 年 | 问题追溯 |
| **进度事件** | 90 天 | 运维调试 |

---

## 七、代码结构建议

```
packages/
└── control-plane/
    └── provisioning/
        ├── index.ts                      # 导出
        ├── types.ts                      # 类型定义
        │
        ├── coordinator/
        │   ├── index.ts
        │   ├── provisioning-coordinator.ts
        │   └── scheduler.ts
        │
        ├── handlers/
        │   ├── db/
        │   │   ├── index.ts
        │   │   ├── allocating-db.handler.ts
        │   │   ├── running-migrations.handler.ts
        │   │   ├── migrating-data.handler.ts
        │   │   ├── verifying.handler.ts
        │   │   └── switching.handler.ts
        │   │
        │   └── instance/
        │       ├── index.ts
        │       ├── allocating-instance.handler.ts
        │       ├── allocating-db.handler.ts
        │       ├── allocating-storage.handler.ts
        │       ├── deploying-app.handler.ts
        │       ├── configuring-domain.handler.ts
        │       ├── issuing-cert.handler.ts
        │       └── verifying.handler.ts
        │
        ├── rollback/
        │   ├── index.ts
        │   ├── db-rollback.strategies.ts
        │   └── instance-rollback.strategies.ts
        │
        ├── providers/
        │   ├── database.provider.ts
        │   ├── instance.provider.ts
        │   ├── storage.provider.ts
        │   └── domain.provider.ts
        │
        └── events/
            ├── index.ts
            ├── event-types.ts
            └── event-emitter.ts
```

---

## 版本历史

| 版本 | 日期 | 变更 |
|------|------|------|
| v1.0 | 2025-12-28 | 初始版本 |

---

**相关文档**：
- [租户隔离三阶段路线图](./租户隔离三阶段路线图.md)
- [租户开通工作流](./租户开通工作流.md)
- [总体架构设计](./总体架构设计.md)

