# dhs-atlas 可逆迁移与一键切换方案（v1.1）

> **版本**: v1.1  
> **创建日期**: 2025-12-28  
> **文档性质**: 架构宪章  
> **相关文档**: [租户隔离三阶段路线图](./租户隔离三阶段路线图.md) · [租户开通蓝图](./租户开通蓝图.md)

---

## 一、总体结论

### 1.1 核心能力

dhs-atlas 的租户隔离模式支持**双向切换**：

```
┌─────────────────────────────────────────────────────────────────────┐
│                      三阶段可逆切换                                  │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│           升级                         升级                         │
│   ┌──────────────►┐           ┌──────────────►┐                    │
│   │               │           │               │                    │
│   │    Shared     │           │  Dedicated    │           Dedicated│
│   │  Multi-tenant │◄─────────►│      DB       │◄─────────►Instance │
│   │               │           │               │           │        │
│   │               │           │               │                    │
│   └◄──────────────┘           └◄──────────────┘                    │
│           降级                         降级                         │
│                                                                     │
│   • 一键切换（平台后台触发）                                         │
│   • 租户不导数据（平台自动完成）                                      │
│   • 可升级也可降级                                                  │
│   • 可审计、可回放、可回滚                                           │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 1.2 两类切换模式

| 模式 | 特点 | 适用场景 |
|------|------|---------|
| **Offline Cutover** | 离线切换，强一致，短暂停写 | 财务、发票、结算期、关键客户 |
| **Online Cutover** | 在线切换，近零停机，双写对账 | 中小客户、非关键窗口、体验优先 |

> 升级/降级都走同一套机制，只是源和目标互换。

---

## 二、必备底座

### 2.1 tenant_runtime 表（从 Phase 1 必须存在）

```sql
CREATE TABLE tenant_runtime (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  enterprise_id UUID NOT NULL UNIQUE REFERENCES enterprise(id),
  
  -- 运行模式
  mode VARCHAR(32) NOT NULL DEFAULT 'shared',
  -- 'shared' | 'dedicated_db' | 'dedicated_instance'
  
  -- 运行状态
  status VARCHAR(32) NOT NULL DEFAULT 'active',
  -- 'active' | 'migrating' | 'maintenance' | 'suspended'
  
  -- 主数据源（当前生效）
  primary_store JSONB NOT NULL DEFAULT '{"type": "shared", "locator": "default"}',
  -- { type: 'shared' | 'dedicated', locator: string }
  
  -- 副数据源（迁移期间）
  secondary_store JSONB,
  -- { type: 'shared' | 'dedicated', locator: string } | null
  
  -- 实例定位（仅 dedicated_instance 模式）
  instance_locator JSONB,
  -- { instanceId: string, host: string } | null
  
  -- 切换版本（单调递增，用于幂等与防抖）
  cutover_version INT NOT NULL DEFAULT 0,
  
  -- 当前迁移作业
  migration_job_id UUID,
  
  -- 域名
  primary_domain VARCHAR(256) NOT NULL,
  custom_domains JSONB DEFAULT '[]',
  
  -- 元数据
  metadata JSONB DEFAULT '{}',
  
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_tenant_runtime_enterprise ON tenant_runtime(enterprise_id);
CREATE INDEX idx_tenant_runtime_mode ON tenant_runtime(mode);
CREATE INDEX idx_tenant_runtime_status ON tenant_runtime(status);
```

### 2.2 migration_job 表（迁移状态机）

```sql
CREATE TABLE migration_job (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  enterprise_id UUID NOT NULL REFERENCES enterprise(id),
  
  -- 迁移方向
  from_mode VARCHAR(32) NOT NULL,
  to_mode VARCHAR(32) NOT NULL,
  
  -- 切换策略
  strategy VARCHAR(32) NOT NULL,
  -- 'offline' | 'online'
  
  -- 迁移阶段
  phase VARCHAR(32) NOT NULL DEFAULT 'pending',
  -- 'pending' | 'snapshot' | 'backfill' | 'dual_write' | 'verify' |
  -- 'cutover' | 'cleanup' | 'done' | 'failed' | 'rolled_back'
  
  phase_history JSONB DEFAULT '[]',
  -- [{ phase, startedAt, completedAt, error? }]
  
  -- 指标
  metrics JSONB DEFAULT '{}',
  -- { totalRows, migratedRows, verifiedRows, discrepancies, checksum }
  
  -- 源/目标配置
  source_store JSONB NOT NULL,
  target_store JSONB NOT NULL,
  
  -- 回滚窗口
  rollback_window_hours INT DEFAULT 24,
  rollback_deadline TIMESTAMPTZ,
  
  -- 操作者与审批
  operator_id UUID NOT NULL,
  approver_ids UUID[],
  approval_status VARCHAR(32) DEFAULT 'pending',
  -- 'pending' | 'approved' | 'rejected'
  
  -- 时间
  requested_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  started_at TIMESTAMPTZ,
  completed_at TIMESTAMPTZ,
  
  -- 错误信息
  error JSONB
);

CREATE INDEX idx_migration_job_enterprise ON migration_job(enterprise_id);
CREATE INDEX idx_migration_job_phase ON migration_job(phase);
CREATE INDEX idx_migration_job_status ON migration_job(approval_status);
```

### 2.3 TypeScript 类型定义

```typescript
// 运行模式
type TenantMode = 'shared' | 'dedicated_db' | 'dedicated_instance';

// 运行状态
type TenantStatus = 'active' | 'migrating' | 'maintenance' | 'suspended';

// 数据源定位
interface StoreLocator {
  type: 'shared' | 'dedicated';
  locator: string;              // 数据库 ID 或连接标识
  metadata?: Record<string, unknown>;
}

// 实例定位
interface InstanceLocator {
  instanceId: string;
  host: string;
  port?: number;
}

// 租户运行时
interface TenantRuntime {
  id: string;
  enterpriseId: string;
  
  mode: TenantMode;
  status: TenantStatus;
  
  primaryStore: StoreLocator;
  secondaryStore?: StoreLocator;
  instanceLocator?: InstanceLocator;
  
  cutoverVersion: number;
  migrationJobId?: string;
  
  primaryDomain: string;
  customDomains: string[];
  
  metadata: Record<string, unknown>;
  
  createdAt: Date;
  updatedAt: Date;
}

// 迁移策略
type MigrationStrategy = 'offline' | 'online';

// 迁移阶段
type MigrationPhase =
  | 'pending'
  | 'snapshot'
  | 'backfill'
  | 'dual_write'
  | 'verify'
  | 'cutover'
  | 'cleanup'
  | 'done'
  | 'failed'
  | 'rolled_back';

// 迁移作业
interface MigrationJob {
  id: string;
  enterpriseId: string;
  
  fromMode: TenantMode;
  toMode: TenantMode;
  
  strategy: MigrationStrategy;
  phase: MigrationPhase;
  phaseHistory: PhaseHistoryEntry[];
  
  metrics: MigrationMetrics;
  
  sourceStore: StoreLocator;
  targetStore: StoreLocator;
  
  rollbackWindowHours: number;
  rollbackDeadline?: Date;
  
  operatorId: string;
  approverIds: string[];
  approvalStatus: 'pending' | 'approved' | 'rejected';
  
  requestedAt: Date;
  startedAt?: Date;
  completedAt?: Date;
  
  error?: MigrationError;
}

interface MigrationMetrics {
  totalRows: number;
  migratedRows: number;
  verifiedRows: number;
  discrepancies: number;
  checksum?: string;
}
```

---

## 三、数据迁移可逆的关键设计

### 3.1 两条路径（升级/降级对称）

```
┌─────────────────────────────────────────────────────────────────────┐
│                        迁移路径                                      │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│   Path 1: Shared ⇄ Dedicated DB                                    │
│   ┌─────────────────────────────────────────────────────────────┐   │
│   │  只变更 DB locator                                           │   │
│   │  应用仍是共享实例，但数据源不同                                │   │
│   │                                                             │   │
│   │  升级: primary_store.locator = dedicated_db_id              │   │
│   │  降级: primary_store.locator = shared_db_id                 │   │
│   └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
│   Path 2: Dedicated DB ⇄ Dedicated Instance                        │
│   ┌─────────────────────────────────────────────────────────────┐   │
│   │  同时变更 instance_locator 与 db locator                     │   │
│   │  数据库迁移仍按 Path 1 协议                                   │   │
│   │  实例切换只是路由层切换                                       │   │
│   │                                                             │   │
│   │  升级: instance_locator = new_instance                      │   │
│   │        primary_store.locator = instance_db_id               │   │
│   │  降级: instance_locator = null                              │   │
│   │        primary_store.locator = dedicated_db_id              │   │
│   └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 3.2 数据复制协议（Copy Contract）

**复制必须满足**：

| 要求 | 说明 |
|------|------|
| **企业范围** | 以 `enterprise_id` 为过滤条件 |
| **幂等** | 可重复执行不产生脏数据 |
| **可校验** | 表级/分区级 checksum 或摘要对比 |
| **可追平** | 支持增量同步（CDC 或基于 event log 的重放） |

```typescript
interface CopyContract {
  // 企业范围
  enterpriseId: string;
  
  // 源/目标
  source: StoreLocator;
  target: StoreLocator;
  
  // 复制选项
  options: {
    // 是否全量
    fullCopy: boolean;
    
    // 增量起点（event offset 或 LSN）
    incrementalFrom?: string;
    
    // 校验级别
    verificationLevel: 'row_count' | 'checksum' | 'full_compare';
    
    // 是否幂等模式（UPSERT vs INSERT）
    idempotent: boolean;
  };
}
```

### 3.3 让"降级"成立的三大前提

#### 前提 1：所有域数据必须是"企业可分片"的

```typescript
// ✅ 正确：每张业务表必须带 enterprise_id
interface Customer {
  id: string;
  enterpriseId: string;  // 必须
  name: string;
  // ...
}

// ❌ 错误：跨企业聚合表作为业务真相源
interface GlobalStats {
  totalCustomers: number;  // 禁止作为业务真相源
}

// ✅ 正确：跨企业聚合改为平台侧只读视图
// CREATE VIEW platform_stats AS SELECT ... GROUP BY ...
```

#### 前提 2：Event Log 必须是迁移的"保险丝"

```typescript
// Event Log 必须保证：
// 1. 迁移窗口内的关键变更能被重放到目标库
// 2. 发生差异能用事件追平

interface MigrationEvent {
  eventId: string;
  enterpriseId: string;
  
  // 事件类型
  eventType: string;
  
  // 完整的变更数据（用于重放）
  payload: {
    table: string;
    operation: 'INSERT' | 'UPDATE' | 'DELETE';
    before?: Record<string, unknown>;
    after?: Record<string, unknown>;
  };
  
  // 时间戳（用于排序和增量）
  timestamp: Date;
  
  // LSN 或 offset（用于精确定位）
  sequence: string;
}

// 降级时，Dedicated 的写入也要能回放到 Shared
async function replayEventsToTarget(
  enterpriseId: string,
  fromSequence: string,
  targetStore: StoreLocator
): Promise<void> {
  const events = await eventLog.query({
    enterpriseId,
    sequenceGte: fromSequence,
    orderBy: 'sequence',
  });
  
  for (const event of events) {
    await applyEventToStore(event, targetStore);
  }
}
```

#### 前提 3：资源产物必须"可搬运或可引用"

```typescript
// 对象存储使用"租户前缀"隔离
const storagePath = `s3://bucket/${enterpriseId}/artifacts/...`;

// 降级策略选择
interface StorageMigrationStrategy {
  type: 'copy' | 'reference_remap';
  
  // copy: 物理复制文件
  copyConfig?: {
    sourceBucket: string;
    targetBucket: string;
    concurrency: number;
  };
  
  // reference_remap: 保留原位置，更新引用表
  remapConfig?: {
    remapTable: string;  // 存储 oldPath -> newPath 映射
  };
}
```

---

## 四、两种切换策略的标准流程

### 4.1 Offline Cutover（强一致，推荐财务窗口）

```
┌─────────────────────────────────────────────────────────────────────┐
│                    Offline Cutover 流程                              │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│   ┌──────────────┐                                                 │
│   │ MAINTENANCE  │  租户进入维护态（只读）                          │
│   │     ON       │                                                 │
│   └──────┬───────┘                                                 │
│          │                                                          │
│          ▼                                                          │
│   ┌──────────────┐                                                 │
│   │   SNAPSHOT   │  记录源库水位（时间戳/LSN/事件 offset）          │
│   └──────┬───────┘                                                 │
│          │                                                          │
│          ▼                                                          │
│   ┌──────────────┐                                                 │
│   │   BACKFILL   │  全量复制 enterprise 数据                       │
│   └──────┬───────┘                                                 │
│          │                                                          │
│          ▼                                                          │
│   ┌──────────────┐                                                 │
│   │  DELTA_SYNC  │  同步 snapshot 之后的差量                       │
│   │              │  (event replay 或 CDC)                          │
│   └──────┬───────┘                                                 │
│          │                                                          │
│          ▼                                                          │
│   ┌──────────────┐                                                 │
│   │    VERIFY    │  校验行数/摘要/关键表一致性                      │
│   └──────┬───────┘                                                 │
│          │                                                          │
│          ▼                                                          │
│   ┌──────────────┐                                                 │
│   │   CUTOVER    │  原子更新 tenant_runtime                        │
│   │              │  primary_store + mode                           │
│   └──────┬───────┘                                                 │
│          │                                                          │
│          ▼                                                          │
│   ┌──────────────┐                                                 │
│   │ MAINTENANCE  │  恢复读写                                       │
│   │     OFF      │                                                 │
│   └──────┬───────┘                                                 │
│          │                                                          │
│          ▼                                                          │
│   ┌──────────────┐                                                 │
│   │   CLEANUP    │  清理 secondary_store、归档作业                 │
│   └──────────────┘                                                 │
│                                                                     │
│   回滚点：cutover 前任意阶段失败可直接退出                          │
│   cutover 后进入"可回滚窗口"                                        │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

**实现代码**：

```typescript
async function executeOfflineCutover(job: MigrationJob): Promise<void> {
  const runtime = await getTenantRuntime(job.enterpriseId);
  
  // 1. 进入维护态
  await updatePhase(job, 'maintenance_on');
  await setTenantStatus(job.enterpriseId, 'maintenance');
  await emitEvent('migration.maintenance_on', { jobId: job.id });
  
  try {
    // 2. 记录水位
    await updatePhase(job, 'snapshot');
    const snapshot = await captureSourceSnapshot(job.sourceStore);
    job.metrics.snapshotLsn = snapshot.lsn;
    
    // 3. 全量复制
    await updatePhase(job, 'backfill');
    const backfillResult = await backfillData(job);
    job.metrics.migratedRows = backfillResult.rowCount;
    
    // 4. 差量同步
    await updatePhase(job, 'delta_sync');
    await syncDelta(job, snapshot.lsn);
    
    // 5. 校验
    await updatePhase(job, 'verify');
    const verifyResult = await verifyConsistency(job);
    if (!verifyResult.passed) {
      throw new VerificationError(verifyResult.discrepancies);
    }
    
    // 6. 原子切换
    await updatePhase(job, 'cutover');
    await atomicCutover(job);
    
    // 7. 恢复读写
    await setTenantStatus(job.enterpriseId, 'active');
    await emitEvent('migration.maintenance_off', { jobId: job.id });
    
    // 8. 设置回滚窗口
    job.rollbackDeadline = new Date(Date.now() + job.rollbackWindowHours * 3600 * 1000);
    
    // 9. 清理
    await updatePhase(job, 'cleanup');
    await scheduleCleanup(job);
    
    await updatePhase(job, 'done');
  } catch (error) {
    // 失败：恢复服务，保持原状态
    await setTenantStatus(job.enterpriseId, 'active');
    await updatePhase(job, 'failed', error);
    throw error;
  }
}

async function atomicCutover(job: MigrationJob): Promise<void> {
  await db.$transaction(async (tx) => {
    // 更新 tenant_runtime
    await tx.tenantRuntime.update({
      where: { enterpriseId: job.enterpriseId },
      data: {
        mode: job.toMode,
        primaryStore: job.targetStore,
        secondaryStore: job.sourceStore, // 保留用于回滚
        cutoverVersion: { increment: 1 },
        migrationJobId: job.id,
        updatedAt: new Date(),
      },
    });
    
    // 记录切换事件
    await tx.eventLog.create({
      data: {
        enterpriseId: job.enterpriseId,
        eventType: 'tenant.cutover',
        payload: {
          jobId: job.id,
          fromMode: job.fromMode,
          toMode: job.toMode,
          cutoverVersion: runtime.cutoverVersion + 1,
        },
        timestamp: new Date(),
      },
    });
  });
  
  // 刷新缓存
  await tenantDbResolver.invalidateCache(job.enterpriseId);
}
```

### 4.2 Online Cutover（近零停机）

```
┌─────────────────────────────────────────────────────────────────────┐
│                    Online Cutover 流程                               │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│   ┌──────────────┐                                                 │
│   │   BACKFILL   │  复制历史数据（后台进行）                        │
│   └──────┬───────┘                                                 │
│          │                                                          │
│          ▼                                                          │
│   ┌──────────────┐                                                 │
│   │ DUAL_WRITE   │  进入"双写"状态                                 │
│   │     ON       │  Repo 层统一执行                                │
│   └──────┬───────┘                                                 │
│          │                                                          │
│          │◄──────── 持续对账（抽样/摘要）                           │
│          │                                                          │
│          ▼                                                          │
│   ┌──────────────┐                                                 │
│   │   VERIFY     │  确认数据一致                                   │
│   │ CONTINUOUS   │                                                 │
│   └──────┬───────┘                                                 │
│          │                                                          │
│          ▼                                                          │
│   ┌──────────────┐                                                 │
│   │   CUTOVER    │  切主（原子更新 runtime）                       │
│   └──────┬───────┘                                                 │
│          │                                                          │
│          ▼                                                          │
│   ┌──────────────┐                                                 │
│   │ DUAL_WRITE   │  关闭双写，目标成为唯一写入                      │
│   │     OFF      │                                                 │
│   └──────┬───────┘                                                 │
│          │                                                          │
│          ▼                                                          │
│   ┌──────────────┐                                                 │
│   │   CLEANUP    │  清理源数据（延迟）                             │
│   └──────────────┘                                                 │
│                                                                     │
│   双写必须由 Repo 层实现，禁止业务层自行决定写哪边                  │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

**双写 Repo 实现**：

```typescript
class DualWriteRepository<T extends BaseEntity> {
  private primaryRepo: Repository<T>;
  private secondaryRepo: Repository<T>;
  private dualWriteEnabled: boolean = false;
  
  async enableDualWrite(secondaryStore: StoreLocator): Promise<void> {
    this.secondaryRepo = await createRepository(secondaryStore);
    this.dualWriteEnabled = true;
  }
  
  async disableDualWrite(): Promise<void> {
    this.dualWriteEnabled = false;
    this.secondaryRepo = null;
  }
  
  async create(data: CreateInput<T>): Promise<T> {
    // 主库写入
    const result = await this.primaryRepo.create(data);
    
    // 双写模式：同步写入副库
    if (this.dualWriteEnabled && this.secondaryRepo) {
      try {
        await this.secondaryRepo.create(data);
      } catch (error) {
        // 双写失败：记录但不阻塞主流程
        await logDualWriteError('create', data, error);
        // 标记需要重新同步
        await markForResync(data.enterpriseId, data.id);
      }
    }
    
    return result;
  }
  
  async update(id: string, data: UpdateInput<T>): Promise<T> {
    const result = await this.primaryRepo.update(id, data);
    
    if (this.dualWriteEnabled && this.secondaryRepo) {
      try {
        await this.secondaryRepo.update(id, data);
      } catch (error) {
        await logDualWriteError('update', { id, data }, error);
        await markForResync(data.enterpriseId, id);
      }
    }
    
    return result;
  }
  
  async delete(id: string): Promise<void> {
    await this.primaryRepo.delete(id);
    
    if (this.dualWriteEnabled && this.secondaryRepo) {
      try {
        await this.secondaryRepo.delete(id);
      } catch (error) {
        await logDualWriteError('delete', { id }, error);
      }
    }
  }
}
```

---

## 五、可逆切换的"回滚窗口"设计

### 5.1 回滚窗口配置

```typescript
interface RollbackWindow {
  // 窗口时长（小时）
  hours: number;                     // 默认 24-72h，可配置
  
  // 截止时间
  deadline: Date;
  
  // 回滚模式
  mode: 'offline' | 'online';
  
  // 是否已过期
  expired: boolean;
}

// 检查是否可回滚
function canRollback(job: MigrationJob): boolean {
  if (job.phase !== 'done') {
    return false;
  }
  
  if (!job.rollbackDeadline) {
    return false;
  }
  
  return new Date() < job.rollbackDeadline;
}
```

### 5.2 回滚流程

#### Offline 模式回滚

```typescript
async function rollbackOffline(job: MigrationJob): Promise<void> {
  // 1. 进入维护态
  await setTenantStatus(job.enterpriseId, 'maintenance');
  
  try {
    // 2. 做差量回放到旧库
    const currentLsn = await captureSourceSnapshot(job.targetStore);
    await replayEventsToStore(
      job.enterpriseId,
      job.metrics.snapshotLsn,  // 从切换点开始
      currentLsn.lsn,
      job.sourceStore            // 回放到原库
    );
    
    // 3. 校验
    const verifyResult = await verifyConsistency({
      source: job.targetStore,
      target: job.sourceStore,
      enterpriseId: job.enterpriseId,
    });
    
    if (!verifyResult.passed) {
      throw new RollbackVerificationError(verifyResult.discrepancies);
    }
    
    // 4. 原子切回
    await atomicRollback(job);
    
    // 5. 恢复服务
    await setTenantStatus(job.enterpriseId, 'active');
    
    // 6. 标记作业为已回滚
    await updatePhase(job, 'rolled_back');
  } catch (error) {
    await setTenantStatus(job.enterpriseId, 'active');
    throw error;
  }
}

async function atomicRollback(job: MigrationJob): Promise<void> {
  await db.$transaction(async (tx) => {
    await tx.tenantRuntime.update({
      where: { enterpriseId: job.enterpriseId },
      data: {
        mode: job.fromMode,
        primaryStore: job.sourceStore,
        secondaryStore: null,
        cutoverVersion: { increment: 1 },
        updatedAt: new Date(),
      },
    });
    
    await tx.eventLog.create({
      data: {
        enterpriseId: job.enterpriseId,
        eventType: 'tenant.rollback',
        payload: {
          jobId: job.id,
          fromMode: job.toMode,
          toMode: job.fromMode,
        },
        timestamp: new Date(),
      },
    });
  });
  
  await tenantDbResolver.invalidateCache(job.enterpriseId);
}
```

#### Online 模式回滚（高价值客户）

```typescript
async function rollbackOnline(job: MigrationJob): Promise<void> {
  // 1. 开启反向双写
  await enableReverseDualWrite(job);
  
  // 2. 等待数据追平
  let synced = false;
  while (!synced) {
    const diff = await compareDatabases(job.targetStore, job.sourceStore, job.enterpriseId);
    if (diff.count === 0) {
      synced = true;
    } else {
      await syncDiff(diff, job.sourceStore);
      await delay(5000); // 等待 5 秒再检查
    }
  }
  
  // 3. 原子切回
  await atomicRollback(job);
  
  // 4. 关闭双写
  await disableDualWrite(job);
  
  await updatePhase(job, 'rolled_back');
}
```

---

## 六、订阅与门禁在可逆迁移中的一致性

### 6.1 一致性要求

无论 Shared/Dedicated，门禁必须一致，否则降级会产生"能力漂移"：

```typescript
// 所有模式统一使用 Entitlement Snapshot
interface EntitlementGate {
  // 检查功能点（与模式无关）
  async checkFeature(enterpriseId: string, feature: string): Promise<boolean> {
    // 1. 获取快照（统一由平台下发）
    const snapshot = await entitlementService.getSnapshot(enterpriseId);
    
    // 2. 校验
    return snapshot.features.some(f => f.featureKey === feature && f.enabled);
  }
}

// Tool Runner Gate（所有模式统一）
async function executeWithGate(input: ToolInput): Promise<ToolResult> {
  const tool = await toolRegistry.get(input.toolId);
  
  for (const feature of tool.requiredFeatures) {
    if (!await entitlementGate.checkFeature(input.enterpriseId, feature)) {
      return { status: 'error', error: { code: 'FEATURE_NOT_ENABLED' } };
    }
  }
  
  return await tool.execute(input);
}
```

### 6.2 迁移期间的门禁控制

```typescript
// 迁移期间的工具白名单
const MIGRATION_ALLOWED_TOOLS = [
  'system.health_check',
  'system.readonly_query',
  // 迁移专用工具
  'migration.copy_data',
  'migration.verify_data',
  'migration.sync_delta',
];

// 迁移期间的门禁
async function checkMigrationGate(
  enterpriseId: string,
  toolId: string
): Promise<boolean> {
  const runtime = await getTenantRuntime(enterpriseId);
  
  // 维护态：只允许白名单工具
  if (runtime.status === 'maintenance') {
    return MIGRATION_ALLOWED_TOOLS.includes(toolId);
  }
  
  // 迁移态（双写模式）：允许正常工具，Repo 层处理双写
  if (runtime.status === 'migrating') {
    return true; // 正常门禁 + 双写
  }
  
  return true;
}
```

---

## 七、平台后台"一键按钮"与安全机制

### 7.1 一键操作

```typescript
// 升级/降级操作
interface MigrationOperation {
  type: 'upgrade' | 'downgrade' | 'rollback';
  from: TenantMode;
  to: TenantMode;
}

const MIGRATION_OPERATIONS: Record<string, MigrationOperation> = {
  'upgrade_to_dedicated_db': {
    type: 'upgrade',
    from: 'shared',
    to: 'dedicated_db',
  },
  'downgrade_to_shared': {
    type: 'downgrade',
    from: 'dedicated_db',
    to: 'shared',
  },
  'upgrade_to_dedicated_instance': {
    type: 'upgrade',
    from: 'dedicated_db',
    to: 'dedicated_instance',
  },
  'downgrade_to_dedicated_db': {
    type: 'downgrade',
    from: 'dedicated_instance',
    to: 'dedicated_db',
  },
  'rollback': {
    type: 'rollback',
    from: null, // 根据当前状态确定
    to: null,   // 回到上一个版本
  },
};
```

### 7.2 审批与审计

```typescript
interface MigrationApproval {
  jobId: string;
  
  // 审批要求
  requiresApproval: boolean;
  approvalPolicy: 'single' | 'dual';  // 单人/双人审批
  
  // 审批状态
  approvals: {
    approverId: string;
    approvedAt: Date;
    comment?: string;
  }[];
  
  // 是否满足审批条件
  isApproved(): boolean {
    if (!this.requiresApproval) return true;
    
    if (this.approvalPolicy === 'single') {
      return this.approvals.length >= 1;
    }
    
    if (this.approvalPolicy === 'dual') {
      return this.approvals.length >= 2;
    }
    
    return false;
  }
}

// 审计记录
interface MigrationAuditEvent {
  eventId: string;
  jobId: string;
  enterpriseId: string;
  
  eventType: 'requested' | 'approved' | 'started' | 'phase_changed' |
             'cutover' | 'rollback' | 'completed' | 'failed';
  
  actor: {
    type: 'user' | 'system';
    id: string;
    name: string;
  };
  
  data: {
    phase?: MigrationPhase;
    metrics?: MigrationMetrics;
    error?: MigrationError;
  };
  
  timestamp: Date;
}
```

### 7.3 平台后台界面

| 功能 | 说明 |
|------|------|
| **一键升级到 Dedicated DB** | 触发 Shared → Dedicated DB 迁移 |
| **一键降级回 Shared** | 触发 Dedicated DB → Shared 迁移 |
| **一键升级到 Dedicated Instance** | 触发 Dedicated DB → Instance 迁移 |
| **一键降级回 Dedicated DB** | 触发 Instance → Dedicated DB 迁移 |
| **一键回滚** | 回滚到上一个 cutover_version |
| **迁移进度面板** | 实时查看迁移阶段、指标 |
| **审批中心** | 处理待审批的迁移请求 |
| **审计日志** | 查看所有迁移操作记录 |

---

## 八、Phase 1 必须立刻实现的"预埋点清单"

### 8.1 数据库表

| 表 | 说明 |
|----|------|
| `tenant_runtime` | 租户运行定位与状态 |
| `migration_job` | 迁移作业状态机 |

### 8.2 Repo 层统一入口

```typescript
// Repo 层必须支持策略注入
interface RepositoryConfig {
  // 主库连接
  primary: DatabaseConnection;
  
  // 副库连接（双写模式）
  secondary?: DatabaseConnection;
  
  // 写入策略
  writeStrategy: 'primary_only' | 'dual_write' | 'secondary_only';
}

// 所有业务 Repo 必须继承
abstract class BaseRepository<T extends BaseEntity> {
  protected config: RepositoryConfig;
  
  // 根据 tenant_runtime 动态获取配置
  protected async getConfig(enterpriseId: string): Promise<RepositoryConfig> {
    const runtime = await tenantDbResolver.getRuntime(enterpriseId);
    
    return {
      primary: await tenantDbResolver.getConnection(runtime.primaryStore),
      secondary: runtime.secondaryStore 
        ? await tenantDbResolver.getConnection(runtime.secondaryStore)
        : undefined,
      writeStrategy: runtime.status === 'migrating' ? 'dual_write' : 'primary_only',
    };
  }
}
```

### 8.3 Event Log 全覆盖

```typescript
// 至少覆盖：
// 1. 所有写操作
// 2. 关键状态变更
// 3. 迁移相关事件

interface EventLogEntry {
  id: string;
  enterpriseId: string;
  
  eventType: string;
  
  // 变更数据（用于重放）
  payload: {
    table?: string;
    operation?: 'INSERT' | 'UPDATE' | 'DELETE';
    before?: Record<string, unknown>;
    after?: Record<string, unknown>;
  };
  
  // 序列号（用于增量同步）
  sequence: bigint;
  
  timestamp: Date;
}
```

### 8.4 Artifact/文件存储路径

```typescript
// 必须使用企业前缀
const getStoragePath = (enterpriseId: string, type: string, id: string): string => {
  return `${BUCKET}/${enterpriseId}/${type}/${id}`;
};

// 示例
const attachmentPath = getStoragePath(enterpriseId, 'attachments', fileId);
// => s3://bucket/ent-123/attachments/file-456
```

### 8.5 平台后台最小迁移控制台

| 功能 | Phase 1 状态 |
|------|-------------|
| 查看 tenant_runtime | 必须实现 |
| 查看 migration_job | 必须实现 |
| 触发迁移（内部使用） | 可选实现 |
| 审计日志查询 | 必须实现 |

---

## 九、最关键的一句话

> 只有当"写路径"可控（Repo 双写/回放），"真相可追溯"（Event Log），并且"租户定位可切换"（tenant_runtime），三阶段才可能来回切换。

---

## 版本历史

| 版本 | 日期 | 变更 |
|------|------|------|
| v1.0 | 2025-12-28 | 初始版本 |
| v1.1 | 2025-12-28 | 增加可逆迁移完整方案 |

---

**相关文档**：
- [租户隔离三阶段路线图](./租户隔离三阶段路线图.md)
- [租户开通蓝图](./租户开通蓝图.md)
- [总体架构设计](./总体架构设计.md)

