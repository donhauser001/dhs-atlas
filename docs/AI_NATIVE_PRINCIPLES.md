# AI 原生系统构建原则

## AI-Native System Construction Principles

本文档定义了本项目在架构、功能设计、交互设计与工程实现层面对"AI 原生系统"的统一理解与不可违背的基本原则。

---

## 核心哲学：结构化自由（Structured Freedom）

> **不通过命令去"驯服"AI，而是通过改变 AI 生存的"重力环境"来引导它。**

这种"尽一切程度减少 AI 的直接束缚"与"四两拨千斤"的工程哲学，实际上是把 AI 看作一种**高熵的能量**，而把系统设计看作**低熵的容器**。

### 以"环境"代"旨意"

要实现对 AI 的"零束缚"，本质上是要将约束从 **逻辑层（Prompt）** 下沉到 **物理层（Architecture）**。

| 传统思路 | 结构化自由 |
|----------|-----------|
| 告诉 AI "不要走出这个圈" | 只在这个圈里铺路 |
| 用规则约束行为 | 用环境塑造行为 |
| 禁止 AI 做某事 | 让 AI 不知道某事存在 |
| 封住 AI 的嘴巴 | 让 AI 没机会说错话 |

### 承认 AI 的本性

AI 的本性是"补全"和"关联"。幻觉的根源在于让 AI 处理了它不该处理的事。

- **顺应本能**：让 AI 做它擅长的事（理解、表达、格式化）
- **剔除重担**：把它不擅长的事（计算、聚合、关联）交给工具

### 三条实践准则

> 1. **如果 AI 犯错，先改工具，不改 Prompt。**（模型是流动的，系统是稳固的）
> 2. **如果 AI 迷惑，先加地图，不加指令。**（方向比流程更重要）
> 3. **如果 AI 幻觉，先封数据，不封嘴巴。**（让它没机会编造，而不是不敢编造）

### 三个杠杆点

| 杠杆点 | 简单操作 | 解决的复杂问题 |
|--------|----------|----------------|
| **工具语义化** | 封装 `crm.contact_stats` | 多表关联、数据准确性、幻觉 |
| **样例定义完成态** | 提供 5-10 个高质量样例 | 输出规范、格式对齐、语气一致 |
| **数据流单向隔离** | 工具返回可直接使用的数据 | 反向想象、二次加工幻觉 |

---

## 一、核心立场（Fundamental Position）

### 原则 1：AI 不是功能模块，而是系统参与者

AI 不被视为某个"功能点"或"辅助工具"，而被视为长期运行在系统中的智能参与者。

系统必须为 AI 提供：

- **可理解的世界**
- **可执行的能力**
- **可验证的结果**

而不是仅仅提供对话接口。

---

### 原则 2：不要通过语言约束 AI

系统禁止依赖大量 Prompt 规则、行为规范或"禁止条款"来约束 AI。

**原因是：**

- 语言约束占用上下文
- 规则越多，AI 推理能力越弱
- AI 会转向语言拟合与投机行为

**正确做法是：**

通过系统结构与能力边界，间接塑造 AI 行为。

#### 反面案例

```
❌ 错误的约束方式（Prompt 规则叠加）：

"你必须遵守以下规则：
1. 禁止编造数据
2. 只能使用工具返回的真实数据
3. 如果某字段为空，必须写'无数据'
4. 禁止猜测
5. 引用原始数据
..."

结果：AI 仍然编造了"张三"、"李四"等不存在的联系人
```

#### 正面案例

```
✅ 正确的约束方式（系统结构塑造）：

不告诉 AI "禁止编造"，而是：
1. 创建 crm.contact_stats 工具
2. 工具在数据库层完成聚合统计
3. 返回结构化的真实数据
4. AI 只能使用这个数据进行格式化输出

结果：AI 无法编造数据，因为它只能输出工具返回的内容
```

---

## 二、世界优先原则（World-First Principle）

### 原则 3：先构建世界，再引入 AI

任何 AI 能力上线之前，必须先定义：

- 这个世界里有什么对象
- 对象之间如何关联
- 哪些行为是真实可执行的

AI 不允许在一个"未定义世界"中运行。

---

### 原则 4：AI 只能在"已知世界"中自由

AI 在系统中拥有充分自由，但其自由只能发生在系统显式定义的世界内。

- **AI 不知道的能力 = 不存在的能力**
- **AI 不能调用的资源 = 不存在的资源**

系统不需要"禁止 AI 做某事"，只需要不让该能力进入 AI 的世界。

---

## 三、能力优先原则（Capability-First Principle）

### 原则 5：所有能力必须工具化

系统中的任何可执行行为，必须以 **工具（Tool）** 形式存在。

**工具的基本要求：**

| 要求 | 说明 |
|------|------|
| 原子化 | 一个工具做一件事 |
| 可执行 | 有明确的执行逻辑 |
| 有明确输入/输出结构 | 参数和返回值有 Schema |
| 明确副作用与边界 | 是否修改数据、是否需要确认 |

**禁止 AI 通过文本"假装执行"某个行为。**

---

### 原则 6：工具 ≠ API

工具是业务语义能力，而不是技术接口暴露。

| 对比 | API | Tool |
|------|-----|------|
| 面向对象 | 系统内部 | AI 的行动选择 |
| 抽象层级 | 技术实现 | 业务语义 |
| 命名风格 | `GET /api/projects?clientId=xxx` | `crm.contact_stats` |

AI 只应理解"能做什么"，而不需要理解"怎么实现"。

---

## 四、稳定认知原则（Stable Cognition Principle）

### 原则 7：数据模型是"世界观"，不是表结构

数据模型库定义的是：

- 实体的业务含义
- 生命周期（状态机）
- 实体之间的语义关系

**而不是：**

- 表字段
- 技术实现细节

数据模型必须是**慢变层**。频繁变动的数据模型，会导致 AI 认知持续崩塌。

---

### 原则 8：事实与派生必须区分

AI 必须清楚区分：

| 类型 | 说明 | 示例 |
|------|------|------|
| **事实** | 存储在数据库中的原始数据 | 客户名称、项目状态 |
| **派生** | 通过计算得出的数据 | 项目数量统计、金额汇总 |

**禁止 AI 基于派生结果反向"想象事实"。**

#### 反面案例

```
AI 收到派生任务："统计中信出版社各联系人的项目数量"

❌ 错误做法：
AI 查询 projects 表，自己遍历 contactNames 字段进行统计
→ AI 可能"想象"出不存在的联系人来填充输出

✅ 正确做法：
系统提供 crm.contact_stats 工具，在数据库层完成统计
→ AI 只能输出工具返回的真实统计结果
```

---

## 五、完成态优先原则（Completion-First Principle）

### 原则 9：输出样例定义"什么算完成"

系统必须提供高质量、结构化的完成态样例。

输出样例的作用不是限制表达，而是定义：

- 合理粒度
- 正确结构
- 可接受的呈现方式

---

### 原则 10：样例少而精

输出样例应当：

- **数量有限** - 不超过 5-10 个核心场景
- **语义典型** - 覆盖最常见的使用模式
- **覆盖关键场景** - 成功/失败/边界情况

**禁止用大量样例替代系统设计。**

---

## 六、方向引导原则（Orientation Principle）

### 原则 11：AI 地图不是流程引擎

AI 地图用于描述：

- 常见任务的典型路径
- 优先顺序
- 常见风险点

**AI 地图是经验地图，不是强制流程。**

---

### 原则 12：允许偏离，但要有"默认道路"

AI 可以偏离地图路径，但系统必须始终提供一条推荐主路。

**没有方向的自由，会退化为混乱。**

---

## 七、交互真实原则（Real Interaction Principle）

### 原则 13：禁止假交互

任何对用户可见的 AI 行为，必须满足至少一项：

- ✅ 查询了真实数据
- ✅ 调用了真实工具
- ✅ 产生了可追溯的状态变化

**禁止为了"看起来聪明"而虚构中间过程。**

---

### 原则 14：前端只呈现"已发生的事实"

前端 UI 只能展示：

- 已执行的动作
- 已查询的数据
- 已生成的结果

**AI 的"思考过程"不是 UI 内容。**

---

## 八、系统优先于模型原则（System-Over-Model Principle）

### 原则 15：不要指望模型"更聪明"来补系统缺陷

如果 AI 表现异常，优先排查：

| 排查顺序 | 检查项 |
|----------|--------|
| 1 | 工具是否缺失 |
| 2 | 数据模型是否模糊 |
| 3 | AI 地图是否缺乏方向 |
| 4 | 样例是否不足 |

**禁止用更复杂 Prompt 或更大模型掩盖架构问题。**

---

## 九、可审计与可演进原则（Auditability & Evolution）

### 原则 16：AI 行为必须可追溯

所有 AI 行为应当能被还原为：

- 使用了哪些工具
- 访问了哪些模型
- 参考了哪些路径

这不是为了监控 AI，而是为了系统演进与质量提升。

---

### 原则 17：演进通过"世界扩展"，而非"规则叠加"

**系统升级的正确方式是：**

- ✅ 新增工具
- ✅ 扩展模型
- ✅ 丰富地图
- ✅ 补充样例

**而不是：**

- ❌ 增加禁止项
- ❌ 叠加提示词
- ❌ 强化语义约束

---

## 十、数据处理原则（Data Processing Principle）

### 原则 18：派生计算在工具层完成

**核心原则：AI 不做数据聚合，工具做。**

```
┌─────────────────────────────────────────────────────────────────┐
│  正确的数据流（无幻觉）                                           │
│                                                                  │
│  数据库 ──▶ 工具（聚合/统计/关联）──▶ 结构化结果 ──▶ AI ──▶ 输出  │
│              ↑                          ↑                        │
│           慢变层                       事实层                     │
│         （可信计算）                （不可编造）                   │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  错误的数据流（容易幻觉）                                         │
│                                                                  │
│  数据库 ──▶ AI（自行聚合/推理）──▶ 输出                          │
│               ↑                                                  │
│            危险区                                                │
│        （可能编造数据）                                           │
└─────────────────────────────────────────────────────────────────┘
```

**原因：** 让 AI 做数据聚合，等于让它"派生事实"，违反原则 8。

---

### 原则 19：复杂查询封装为专用工具

当查询涉及以下情况时，必须创建专用工具：

| 情况 | 示例 | 工具化方案 |
|------|------|-----------|
| 多表关联 | 项目 + 结算表 | `crm.project_with_settlement` |
| 数据聚合 | 按联系人统计项目数 | `crm.contact_stats` |
| 复杂计算 | 计算利润率、完成率 | `analytics.profit_rate` |
| 时间范围 | 本月/本季度统计 | `analytics.period_stats` |

**原因：** 这些操作需要精确的业务逻辑，不能依赖 AI 的"理解"。

---

## 十一、防幻觉原则（Anti-Hallucination Principle）

### 原则 20：幻觉的根源是"让 AI 处理它不该处理的事"

**幻觉的本质：**

```
AI 被要求输出某些信息，但它没有获得这些信息的可靠来源
→ AI 会基于训练数据和上下文"补全"缺失信息
→ 产生幻觉
```

**解决思路：**

不是"告诉 AI 不要编造"，而是"让 AI 不需要编造"。

---

### 原则 21：数据从工具流向输出，不经 AI 加工

```
┌──────────────────────────────────────────────────────────┐
│                   防幻觉架构                              │
├──────────────────────────────────────────────────────────┤
│                                                          │
│   用户请求                                                │
│      │                                                   │
│      ▼                                                   │
│   ┌─────┐                                                │
│   │ AI  │ ─── 决策：调用什么工具 ───┐                     │
│   └─────┘                          │                     │
│                                    ▼                     │
│                              ┌──────────┐                │
│                              │   工具   │                │
│                              │ 执行查询 │                │
│                              │ 数据聚合 │                │
│                              └────┬─────┘                │
│                                   │                      │
│                          结构化真实数据                   │
│                                   │                      │
│                                   ▼                      │
│   ┌─────┐                                                │
│   │ AI  │ ─── 格式化输出（只能用返回的数据）              │
│   └─────┘                                                │
│      │                                                   │
│      ▼                                                   │
│   用户看到的结果（真实数据，无幻觉）                       │
│                                                          │
└──────────────────────────────────────────────────────────┘
```

---

### 原则 22：工具返回值必须是"可直接使用"的

**错误示例：**

```json
// 工具返回原始数据，让 AI 自己处理
{
  "projects": [
    {"name": "项目A", "contactNames": ["张三"], "settlementId": "xxx"},
    {"name": "项目B", "contactNames": ["李四", "张三"], "settlementId": "yyy"}
  ],
  "settlements": [
    {"_id": "xxx", "amount": 10000},
    {"_id": "yyy", "amount": 20000}
  ]
}
// AI 需要自己关联、聚合 → 容易幻觉
```

**正确示例：**

```json
// 工具返回已处理的结构化数据
{
  "clientName": "中信出版社",
  "contacts": [
    {"name": "张三", "projectCount": 2, "totalAmount": 30000, "projects": "项目A, 项目B"},
    {"name": "李四", "projectCount": 1, "totalAmount": 20000, "projects": "项目B"}
  ],
  "summary": {
    "topByCount": "张三（2个项目）",
    "topByAmount": "张三（¥30000）"
  }
}
// AI 只需格式化输出，无需处理 → 无幻觉
```

---

## 十二、最终原则（终极判断标准）

### 原则 23：如果 AI 不能操作它，这是失败的设计

任何功能、模块、脚本、流程：

**如果 AI 无法通过工具与模型完成操作，即使人类可以，这也是失败的系统设计。**

---

### 原则 24：如果 AI 产生幻觉，这是系统的失败

当 AI 输出虚假信息时，不要责怪 AI 或模型。

**正确的反思方向：**

| 检查项 | 问题 | 解决方案 |
|--------|------|----------|
| 工具 | 是否缺少聚合工具？ | 创建专用工具 |
| 数据流 | AI 是否需要自己处理数据？ | 让工具完成处理 |
| 返回值 | 工具返回值是否需要二次加工？ | 返回可直接使用的数据 |
| 样例 | 是否缺少输出样例？ | 补充典型样例 |

---

## 实践案例：解决幻觉问题

### 问题描述

用户请求："中信出版社有哪些联系人，哪个人给我们的项目最多"

**最初的实现：**

```
AI 调用 db.query 查询 projects 表
→ AI 自己遍历 contactNames 字段
→ AI 自己统计每个联系人的项目数
→ AI 输出统计结果
```

**结果：** AI 编造了"张三"、"李四"等不存在的联系人。

---

### 尝试 1：Prompt 约束（失败）

```
在系统提示中添加：
- "禁止编造数据"
- "只能使用工具返回的真实数据"
- "如果某字段为空，写'无数据'"
```

**结果：** AI 仍然编造数据。**违反原则 2。**

---

### 尝试 2：创建聚合工具（成功）

创建 `crm.contact_stats` 工具：

```typescript
// 工具在数据库层完成所有聚合
export const contactStatsTool: ToolDefinition = {
    id: 'crm.contact_stats',
    name: '联系人项目统计',
    
    async execute(params) {
        // 1. 查询项目
        const projects = await db.collection('projects').find({
            clientName: { $regex: params.clientName, $options: 'i' }
        }).toArray();
        
        // 2. 在工具层聚合统计
        const contactMap = new Map();
        for (const project of projects) {
            for (const name of project.contactNames || []) {
                if (!contactMap.has(name)) {
                    contactMap.set(name, { name, count: 0, projects: [] });
                }
                const stat = contactMap.get(name);
                stat.count++;
                stat.projects.push(project.projectName);
            }
        }
        
        // 3. 返回结构化的真实数据
        return {
            success: true,
            data: {
                clientName: params.clientName,
                contacts: Array.from(contactMap.values()),
                summary: { topByCount: '...' }
            }
        };
    }
};
```

**结果：** AI 输出完全准确，因为它只能使用工具返回的真实数据。

---

### 对比总结

| 方案 | 数据处理位置 | 结果 | 符合原则 |
|------|--------------|------|----------|
| Prompt 约束 | AI 层 | ❌ 幻觉 | 违反原则 2, 8 |
| 聚合工具 | 工具层 | ✅ 准确 | 符合原则 5, 18, 21 |

---

## 结语（系统宣言）

> **我们不试图驯服 AI，我们为 AI 构建世界。**
>
> **当世界是真实的，自由自然会变得可靠。**
>
> **当工具是完善的，幻觉自然会消失。**

---

## 附录：原则速查表

| 编号 | 原则名称 | 核心要点 |
|------|----------|----------|
| 1 | AI 是系统参与者 | 提供世界、能力、结果 |
| 2 | 不通过语言约束 | 用系统结构塑造行为 |
| 3 | 先构建世界 | 定义对象、关系、行为 |
| 4 | 已知世界中自由 | 不存在的能力 = 不能调用 |
| 5 | 能力必须工具化 | 原子化、可执行、有 Schema |
| 6 | 工具 ≠ API | 面向业务语义 |
| 7 | 数据模型是世界观 | 慢变层，不是表结构 |
| 8 | 事实与派生区分 | 禁止反向想象 |
| 9 | 样例定义完成态 | 结构、粒度、呈现方式 |
| 10 | 样例少而精 | 不超过 10 个核心场景 |
| 11 | 地图不是流程引擎 | 经验地图，非强制流程 |
| 12 | 有默认道路 | 允许偏离，但有推荐路径 |
| 13 | 禁止假交互 | 必须有真实操作 |
| 14 | 只呈现已发生事实 | 思考过程不是 UI |
| 15 | 系统优先于模型 | 不用更大模型补缺陷 |
| 16 | 行为可追溯 | 用于演进与质量提升 |
| 17 | 世界扩展演进 | 新增工具，而非叠加规则 |
| 18 | 派生在工具层 | AI 不做数据聚合 |
| 19 | 复杂查询工具化 | 多表关联、聚合封装 |
| 20 | 幻觉根源 | AI 处理了不该处理的事 |
| 21 | 数据不经 AI 加工 | 从工具直接到输出 |
| 22 | 返回值可直接使用 | 无需二次处理 |
| 23 | AI 不能操作 = 失败设计 | 终极判断标准 |
| 24 | 幻觉 = 系统失败 | 不责怪 AI，改进系统 |

---

*文档版本：v1.0*
*最后更新：2024年12月*
*维护者：开发团队*

