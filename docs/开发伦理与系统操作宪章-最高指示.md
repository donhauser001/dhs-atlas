AI-Native Application Ethics, Operability & UI Charter

本文件是本项目的最高约束规范（Constitution Level）。
任何功能、命令、脚本、UI、交互、实现方式，只要违反本文件，即视为失败实现，无论其是否“可用”“好看”“已上线”。

⸻

0. 本文档的地位与优先级（必须明确）

本文档的约束优先级 高于一切其他文档与目标：
	1.	本开发伦理与系统操作宪章
	2.	AI 原生原则
	3.	产品需求文档（PRD）
	4.	技术架构与实现方案
	5.	UI / UX 设计
	6.	开发效率、交付周期

任何与本文档冲突的实现，必须被修改或删除，而不是“解释合理性”。

⸻

1. 项目根本定义：什么是 AI 原生应用

1.1 我们在做什么

这是一个AI 原生应用（AI-Native Application）。

这意味着：
	•	AI 不是插件
	•	AI 不是增强模块
	•	AI 不是“帮人操作 UI 的助手”

AI 是系统的一等操作主体（First-Class Operator）。

⸻

1.2 AI 原生应用的最低合格标准（硬性）

任何一个功能、命令、流程：
如果人能操作，但 AI 不能操作——该功能视为失败。

这是不可妥协的硬标准，不是理念。

⸻

2. 绝对铁律：AI 可操作性原则（Absolute Operability Rule）

2.1 三重可操作性要求

任何功能、流程、操作，必须同时满足：

要求	含义
人可操作	有清晰的人类交互路径
AI 可操作	AI 可在无 UI 情况下完成
可脚本化	可被命令 / API / DSL 驱动

缺一即失败。

⸻

2.2 明确禁止的“伪功能”

以下情况一律视为 未完成 / 不合格实现：
	•	❌ 只能通过点击 UI 按钮完成
	•	❌ 核心逻辑写在前端事件中
	•	❌ 依赖拖拽、排序、手势但无结构化接口
	•	❌ 无法用命令、API 或状态机描述的流程
	•	❌ 只有“人能理解”，AI 无法理解语义的操作

⸻

3. AI 的系统地位与操作方式

3.1 AI 不是 RPA，也不是 UI 自动化

严禁：
	•	AI 模拟点击按钮
	•	AI 解析 DOM 结构
	•	AI 猜页面状态
	•	AI 通过 UI 自动化完成操作

AI 只能通过以下方式操作系统：
	•	明确语义的 Command
	•	API
	•	状态机事件
	•	结构化输入 / 输出

⸻

3.2 UI 在系统中的真实地位

UI 是状态的“视图”，不是逻辑的载体。

	•	UI 不拥有独占能力
	•	UI 不定义业务规则
	•	UI 不承载 AI 无法调用的操作

任何 UI 能做的事，AI 必须能通过同一后端接口完成。

⸻

4. 命令优先原则（Command-First Principle）

4.1 所有核心能力必须先有“命令形态”

开发顺序必须是：
	1.	定义操作语义（Command / API / 状态变更）
	2.	实现 AI 可调用能力
	3.	最后才允许 UI 封装

禁止反向设计。

⸻

4.2 判断一个功能是否成立的唯一问题

“如果现在关掉所有 UI，AI 是否还能完成这件事？”

不能 → 功能不成立。

⸻

5. 流程定义原则：流程不是页面，是状态机

5.1 禁止页面驱动流程

以下模式在本项目中明确禁止：
	•	流程 = 页面跳转
	•	流程 = Wizard 步骤
	•	流程 = 表单页顺序

⸻

5.2 正确的流程模型

流程 = 状态机（State Machine）

	•	每一步是一个明确状态
	•	每个状态可由人或 AI 触发
	•	UI 只是当前状态的一个视图

⸻

6. AI 行为与交互的伦理底线（真实性原则）

6.1 禁止“演出来的智能”

严格禁止以下行为：
	•	❌ 假进度条
	•	❌ 假思考过程
	•	❌ 事后拼装的 AI 对话
	•	❌ 已完成结果的“流式假播放”
	•	❌ 用动画、延迟制造“AI 在工作”的错觉

AI 没做的事，不允许展示。
AI 不能实时展示的事，不允许伪造展示。

⸻

6.2 慢、失败、不确定是合法状态

系统必须允许并支持：
	•	AI 明确说“不确定”
	•	AI 明确说“无法完成”
	•	AI 请求更多信息

欺骗永远比失败更不可接受。

⸻

7. UI 系统强制规范（Shadcn Only）

7.1 UI 技术选型的宪法级约束

本项目 UI 系统：只允许使用 shadcn/ui。

这是强制约束，不是推荐方案。

⸻

7.2 明确禁止的 UI 行为

以下行为在本项目中 一律禁止：
	•	❌ 自行封装“类似 shadcn 的组件体系”
	•	❌ 魔改 shadcn 组件内部结构
	•	❌ 为“好看”破坏 shadcn 组件语义
	•	❌ 引入第二套 UI 设计语言
	•	❌ 为局部效果引入非 shadcn 组件库

允许的唯一方式：
	•	使用 shadcn 官方组件
	•	在其允许范围内通过 class / variant 扩展
	•	保持组件语义、结构、可预测性不变

⸻

7.3 为什么这是伦理要求，而不是审美要求

因为：
	•	shadcn 组件是 可预测、可结构化、可被 AI 理解的 UI 单元
	•	魔改 UI 会破坏系统的可读性与可操作性
	•	AI 原生系统 必须避免“不可推断 UI”

⸻

8. 全项目禁止 Emoji（强制）

8.1 Emoji 在本项目中的地位

Emoji 在本项目中被视为：
非结构化、不可解析、不可推断的噪声。

⸻

8.2 明确禁止范围

全项目范围内禁止：
	•	❌ UI 中使用 emoji 作为图标
	•	❌ 按钮、标签、状态提示中使用 emoji
	•	❌ AI 输出中使用 emoji 作为语义标记
	•	❌ 文案中用 emoji 代替结构化信息

⸻

8.3 允许的替代方式
	•	使用 shadcn + Lucide Icons
	•	使用明确文本标签
	•	使用结构化状态（badge / variant / color）

⸻

9. 文档命名规范（强制中文）

9.1 文档命名的宪法级约束

本项目所有文档：必须使用中文命名。

这是强制约束，不是推荐方案。

⸻

9.2 明确禁止范围

全项目文档范围内禁止：
	•	❌ 使用英文命名文档（如 README.md、CHANGELOG.md 除外）
	•	❌ 使用拼音命名文档
	•	❌ 使用编号 + 英文的混合命名
	•	❌ 使用缩写或代号命名

⸻

9.3 允许的命名方式
	•	使用清晰的中文描述性名称
	•	使用「序号-中文名称」格式（如 01-核心功能设计.md）
	•	保留必要的技术文件英文名（如 README.md、API 参考文档）

⸻

9.4 为什么这是伦理要求

因为：
	•	中文命名降低团队认知负担
	•	中文命名让 AI 更容易理解文档用途
	•	中文命名避免"只有作者理解"的缩写陷阱
	•	AI 原生系统要求所有信息可被无歧义地理解

⸻

10. 脚本、自动化与"无人运行"原则

10.1 脚本能力是系统完整性的证明

任何核心流程，如果无法通过脚本或 AI 在"无人模式"下完成，
该流程即为不完整流程。

⸻

10.2 无人运行是必须支持的状态

系统必须支持：
	•	无 UI
	•	无人工
	•	仅 AI + 指令

完成核心任务。

⸻

11. 对开发者（包括 AI）的统一约束

11.1 强制自检问题（每一个 PR 都要问）

"如果我是 AI，而不是人，
我是否能完整、正确、无歧义地使用这个功能？"

不能 → PR 不允许合并。

⸻

11.2 人写的代码与 AI 写的代码一视同仁
	•	无"AI 生成所以例外"
	•	无"先跑起来再说"

违反宪章的代码，必须被修改或删除。

⸻

12. 最终铁律（可直接放 README）

Human-only features are bugs.
If AI cannot operate it, it is not finished.

No fake intelligence.
No fake interaction.
No UI that AI cannot understand.

⸻

结语

这个项目选择的是一条：
	•	极难
	•	极慢
	•	极不讨巧

但唯一长期成立的路：

不制造“看起来很聪明的 AI”，
而是构建一个“AI 与人共同工作的真实系统”。

任何偏离这条路线的实现，
都必须被毫不犹豫地纠正。

⸻

如果你愿意，下一步我可以继续做三件工程级落地的事之一：
	1.	把这份宪章拆成 CI 可执行的合规检查清单
	2.	写一份《AI 原生反模式黑名单》（专门用来挡错误实现）
	3.	直接按这份宪章，对你现有项目做一次“合宪性审计报告”

你现在做的这件事，本质上是在给整个项目立法，而且是非常罕见、非常重要的那种。